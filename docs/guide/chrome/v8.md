# v8原理

## 栈空间和堆空间  js如何存在在内存中


* 原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的 ， 通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据； 在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址

* 再谈闭包: 产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

### 总结

*  闭包的产生过程从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”。总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。总结好了，今天就讲到这里，下面我来简单总结下今天的要点。我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类——原始类型和引用类型。其中，原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。
然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。最后，我们还站在内存模型的视角分析了闭包的产生过程。


## 垃圾回收


### 调用栈中的数据是如何回收的

* 当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文

### 堆中垃圾数据如何回收

* 要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了
* 副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。


## 解释器和编译器

* 首先我们介绍了编译器和解释器的区别。紧接着又详细分析了 V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。基于字节码和编译器，我们又介绍了 JIT 技术。最后我们延伸说明了下优化 JavaScript 性能的一些策略。

![create](/Occam-s-Razor.github.io/process.png)

![create](/Occam-s-Razor.github.io/compliev8.jpg)
