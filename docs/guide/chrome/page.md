# 浏览器中的页面循环系统

## 消息队列和事件循环

### 原因

* 既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件, 需要统筹调度系统;统筹调度系统就是我
们今天要讲的消息队列和事件循环系统

![create](/Occam-s-Razor.github.io/networkIo.jpg)

### 消息队列的类型

* 输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器; 消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析DOM、样式计算、布局计算、CSS 动画等

### 页面使用单线程的缺点


#### 1.如何处理高优先级的任务

* 我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题


#### 如何解决单个任务执行时长过久的问题

* 。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的JavaScript 任务滞后执行。


### 总结

* 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。

* 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO线程，IO 线程再把任务发送给页面主线程。消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务

## setTimeout

### 注意事项
* 如果当前任务执行时间过久，会影延迟到期定时器任务的执行


```
function bar() {    console.log('bar')}function foo() {    setTimeout(bar, 0);    for (let i = 0; i < 5000; i++) {        let i = 5+8+8+8        console.log(i)    }}foo()复制代码
```

* setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒

* 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒

* 延时执行时间有最大值  2147483647

* setTimeout 设置的回调函数中的 this 不符合直觉

### raf和setTimeout的区别


* requestAnimationFrame 提供一个原生的API去执行动画的效果，它会在一帧（一般是16ms）间隔内根据选择浏览器情况去执行相关动作。setTimeout是在特定的时间间隔去执行任务，不到时间间隔不会去执行，这样浏览器就没有办法去自动优化

